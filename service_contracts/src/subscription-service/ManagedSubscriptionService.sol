// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {Payments, IArbiter} from "@fws-payments/Payments.sol";
import {ServiceUptimeListener, ServiceUptimeVerifier} from "./ServiceUptimeVerifier.sol";

/// @title ManagedSubscriptionService (Service Level Agreement Contract)
/// @notice Service Level Agreement (SLA) contract that handles payments based on uptime verification
/// @dev This contract implements ServiceUptimeListener to receive uptime data from ServiceUptimeVerifier.
/// It separates verification (SLI) from payment enforcement (SLA) following the PDPVerifier pattern.
contract ManagedSubscriptionService is ServiceUptimeListener, IArbiter, Initializable, UUPSUpgradeable, OwnableUpgradeable {

    event FilecoinServiceCreated(string indexed serviceName);
    event ServiceProviderActivated(uint256 indexed serviceId, uint256 railId, address serviceProvider);
    event ServiceProviderDeactivated(uint256 indexed serviceId, uint256 railId);
    event UsagePaymentSent(address indexed serviceProvider, uint256 amount, string reason);
    event UptimeVerifierUpdated(address oldVerifier, address newVerifier);

    // Constants
    uint256 public constant DEFAULT_LOCKUP_PERIOD = 2880 * 10; // 10 days in epochs
    uint256 public constant EPOCHS_PER_MONTH = 2880 * 30;
    uint256 public constant MAX_SERVICE_DESCRIPTION_SIZE = 1024; // 1KB service description limit
    
    // Service configuration (set during initialization)
    string public serviceName;
    string public serviceDescription;
    uint256 public monthlyServiceRate; // Monthly rate in USDFC
    uint256 public lockupPeriod; // Lockup period in epochs, default 0

    // Token decimals
    uint8 public tokenDecimals;

    // External contract addresses
    address public paymentsContractAddress;
    address public usdfcTokenAddress;
    address public uptimeVerifierAddress;

    // Note: Service IDs are generated by ServiceUptimeVerifier


    // Storage for service payment information
    struct ServiceInfo {
        uint256 railId; // ID of the payment rail
        address serviceProvider; // Service provider address
        string metadata; // General metadata for the service
        uint256 ratePerEpoch; // Current rate per epoch
        bool active; // Whether the service is active
        uint256 createdAt; // Block number when service was created
    }

    // Mappings
    mapping(uint256 => ServiceInfo) public serviceInfo;
    mapping(address => uint256) public providerToServiceId; // One service per provider

    // Mapping from rail ID to service ID for arbitration
    mapping(uint256 => uint256) public railToService;

    // Event for arbitration
    event PaymentArbitrated(
        uint256 railId, uint256 serviceId, uint256 originalAmount, uint256 modifiedAmount
    );

    // ========== Service Provider Registry State ==========
    
    uint256 public nextProviderId = 1;
        
    struct ApprovedProviderInfo {
        address owner;
        uint256 registeredAt; 
        uint256 approvedAt;   
    }
    
    struct PendingProviderInfo {
        uint256 registeredAt; 
    }
    
    mapping(uint256 => ApprovedProviderInfo) public approvedProviders;
    mapping(address => bool) public approvedProvidersMap;
    mapping(address => PendingProviderInfo) public pendingProviders;
    mapping(address => uint256) public providerToId;
    
    // Events for SP registry
    event ProviderRegistered(address indexed provider);
    event ProviderApproved(address indexed provider, uint256 indexed providerId);
    event ProviderRejected(address indexed provider);
    event ProviderRemoved(address indexed provider, uint256 indexed providerId);

    // Modifier to ensure only the uptime verifier can call certain functions
    modifier onlyUptimeVerifier() {
        require(msg.sender == uptimeVerifierAddress, "Caller is not the uptime verifier");
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address _paymentsContractAddress,
        address _usdfcTokenAddress,
        address _uptimeVerifierAddress,
        string calldata _serviceName,
        string calldata _serviceDescription,
        uint256 _monthlyRateUSDFC,
        uint256 _lockupPeriod
    ) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();

        require(_paymentsContractAddress != address(0), "Payments contract address cannot be zero");
        require(_usdfcTokenAddress != address(0), "USDFC token address cannot be zero");
        require(_uptimeVerifierAddress != address(0), "Uptime verifier address cannot be zero");
        require(bytes(_serviceName).length > 0, "Service name cannot be empty");
        require(bytes(_serviceDescription).length <= MAX_SERVICE_DESCRIPTION_SIZE, "Service description too large");
        require(_monthlyRateUSDFC > 0, "Monthly rate must be greater than 0");

        paymentsContractAddress = _paymentsContractAddress;
        usdfcTokenAddress = _usdfcTokenAddress;
        uptimeVerifierAddress = _uptimeVerifierAddress;
        serviceName = _serviceName;
        serviceDescription = _serviceDescription;
        monthlyServiceRate = _monthlyRateUSDFC;
        lockupPeriod = _lockupPeriod;

        // Read token decimals from the USDFC token contract
        tokenDecimals = IERC20Metadata(_usdfcTokenAddress).decimals();

        nextProviderId = 1;
        
        // Emit deployment event
        emit FilecoinServiceCreated(_serviceName);
    }

    /**
     * @notice Initialize with default lockup period (0)
     * @dev Overloaded function for backward compatibility
     */
    function initialize(
        address _paymentsContractAddress,
        address _usdfcTokenAddress,
        address _uptimeVerifierAddress,
        string calldata _serviceName,
        string calldata _serviceDescription,
        uint256 _monthlyRateUSDFC
    ) public initializer {
        initialize(
            _paymentsContractAddress,
            _usdfcTokenAddress,
            _uptimeVerifierAddress,
            _serviceName,
            _serviceDescription,
            _monthlyRateUSDFC,
            0 // Default lockup period of 0
        );
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /**
     * @notice Update the uptime verifier contract address
     * @dev Only callable by the contract owner
     * @param newVerifier New uptime verifier contract address
     */
    function updateUptimeVerifier(address newVerifier) external onlyOwner {
        require(newVerifier != address(0), "Verifier cannot be zero address");
        address oldVerifier = uptimeVerifierAddress;
        uptimeVerifierAddress = newVerifier;
        emit UptimeVerifierUpdated(oldVerifier, newVerifier);
    }

    /**
     * @notice Activates a service provider with payment rail and uptime tracking
     * @dev Called by the contract owner to activate a service provider
     * @param serviceProvider The address of the service provider
     * @param metadata Service metadata
     * @return serviceId The ID of the newly activated service
     */
    function activateServiceProvider(address serviceProvider, string calldata metadata) external onlyOwner returns (uint256) {
        // Validate the address
        require(serviceProvider != address(0), "Service provider address cannot be zero");
        
        // Check if the service provider is approved
        require(approvedProvidersMap[serviceProvider], "Service provider not approved");
        
        // Check if service provider already has an active service
        uint256 existingServiceId = providerToServiceId[serviceProvider];
        if (existingServiceId != 0) {
            require(!serviceInfo[existingServiceId].active, "Service provider already has an active service");
        }

        // Register service with uptime verifier first (let it generate the ID)
        bytes memory extraData = abi.encode(serviceProvider, metadata);
        uint256 serviceId = ServiceUptimeVerifier(uptimeVerifierAddress).registerService(
            address(this), // This contract will receive uptime callbacks
            extraData
        );
        providerToServiceId[serviceProvider] = serviceId;

        // Calculate the rate per epoch based on configured monthly rate
        uint256 monthlyRateWithDecimals = monthlyServiceRate * (10 ** uint256(tokenDecimals));
        uint256 ratePerEpoch = monthlyRateWithDecimals / EPOCHS_PER_MONTH;


        // Initialize the ServiceInfo struct
        ServiceInfo storage info = serviceInfo[serviceId];
        info.serviceProvider = serviceProvider;
        info.metadata = metadata;
        info.ratePerEpoch = ratePerEpoch;
        info.active = true;
        info.createdAt = block.number;

        // Create the payment rail using the Payments contract
        // The service contract itself is the payer
        Payments payments = Payments(paymentsContractAddress);
        uint256 railId = payments.createRail(
            usdfcTokenAddress, // token address
            address(this), // from (this contract as payer)
            serviceProvider, // service provider as payee
            address(this), // this contract acts as the arbiter
            0 // no commission
        );

        // Store the rail ID
        info.railId = railId;

        // Store reverse mapping from rail ID to service ID for arbitration
        railToService[railId] = serviceId;

        // Set lockup period (configurable)
        payments.modifyRailLockup(
            railId,
            lockupPeriod, // Configurable lockup period
            0 // No upfront lockup required
        );

        // Set the recurring payment rate (no upfront payment)
        payments.modifyRailPayment(
            railId,
            ratePerEpoch, // Recurring rate per epoch
            0 // No one-time payment
        );

        // Report initial online status to uptime verifier
        ServiceUptimeVerifier(uptimeVerifierAddress).reportUptime(
            serviceId,
            true, // Start online by default
            extraData
        );

        // Emit event for tracking
        emit ServiceProviderActivated(serviceId, railId, serviceProvider);

        return serviceId;
    }

    /**
     * @notice Deactivates a service provider and terminates the payment rail
     * @dev Can only be called by the contract owner
     * @param serviceId The ID of the service to deactivate
     */
    function deactivateServiceProvider(uint256 serviceId) external onlyOwner {
        // Verify the service exists
        ServiceInfo storage info = serviceInfo[serviceId];
        require(info.railId != 0, "Service not found");
        require(info.active, "Service already inactive");

        // Mark service as inactive
        info.active = false;

        // Deregister from uptime verifier
        bytes memory extraData = abi.encode(serviceId, info.serviceProvider);
        ServiceUptimeVerifier(uptimeVerifierAddress).deregisterService(serviceId, extraData);

        // Terminate the payment rail
        Payments payments = Payments(paymentsContractAddress);
        payments.modifyRailPayment(info.railId, 0, 0); // Set rate to 0

        emit ServiceProviderDeactivated(serviceId, info.railId);
    }

    /**
     * @notice Set a service provider as offline (not providing service)
     * @dev Can only be called by the contract owner
     * @param serviceProvider The address of the service provider
     */
    function setServiceProviderOffline(address serviceProvider) external onlyOwner {
        require(approvedProvidersMap[serviceProvider], "Service provider not approved");
        
        // Find the active service for this provider
        uint256 serviceId = providerToServiceId[serviceProvider];
        if (serviceId != 0 && serviceInfo[serviceId].active) {
            bytes memory extraData = abi.encode(serviceId, serviceProvider);
            ServiceUptimeVerifier(uptimeVerifierAddress).reportUptime(
                serviceId,
                false, // Set offline
                extraData
            );
        }
    }
    
    /**
     * @notice Set a service provider as online (providing service)
     * @dev Can only be called by the contract owner
     * @param serviceProvider The address of the service provider
     */
    function setServiceProviderOnline(address serviceProvider) external onlyOwner {
        require(approvedProvidersMap[serviceProvider], "Service provider not approved");
        
        // Find the active service for this provider
        uint256 serviceId = providerToServiceId[serviceProvider];
        if (serviceId != 0 && serviceInfo[serviceId].active) {
            bytes memory extraData = abi.encode(serviceId, serviceProvider);
            ServiceUptimeVerifier(uptimeVerifierAddress).reportUptime(
                serviceId,
                true, // Set online
                extraData
            );
        }
    }

    /**
     * @notice Allows the contract to deposit USDFC tokens for payments
     * @dev Only the owner can deposit funds
     * @param amount The amount of USDFC to deposit
     */
    function depositFunds(uint256 amount) external onlyOwner {
        require(amount > 0, "Amount must be greater than 0");
        
        // Transfer tokens from owner to this contract
        IERC20(usdfcTokenAddress).transferFrom(msg.sender, address(this), amount);
        
        // Deposit into the payments contract
        IERC20(usdfcTokenAddress).approve(paymentsContractAddress, amount);
        Payments(paymentsContractAddress).deposit(usdfcTokenAddress, address(this), amount);
    }
    
    /**
     * @notice Allows the owner to withdraw unused funds
     * @param amount The amount to withdraw
     */
    function withdrawFunds(uint256 amount) external onlyOwner {
        Payments(paymentsContractAddress).withdraw(usdfcTokenAddress, amount);
        IERC20(usdfcTokenAddress).transfer(msg.sender, amount);
    }

    /**
     * @notice Send a usage-based payment to a service provider via the rail system
     * @dev Uses one-time payments through the existing payment rail with automatic lockup management
     * @param serviceProvider The address of the service provider
     * @param amount The amount to pay (in USDFC with decimals)
     * @param reason Description of why this payment is being made (e.g., "High usage period", "Performance metrics")
     */
    function sendUsagePayment(address serviceProvider, uint256 amount, string calldata reason) external onlyOwner {
        require(amount > 0, "Amount must be greater than 0");
        require(approvedProvidersMap[serviceProvider], "Service provider not approved");
        require(bytes(reason).length > 0, "Reason cannot be empty");
        require(bytes(reason).length <= 256, "Reason too long");
        
        // Find the active service for this provider
        uint256 serviceId = providerToServiceId[serviceProvider];
        require(serviceId != 0, "Service provider has no active service");
        
        ServiceInfo storage service = serviceInfo[serviceId];
        require(service.active, "Service is not active");
        
        // Get current rail information
        Payments payments = Payments(paymentsContractAddress);
        Payments.RailView memory rail = payments.getRail(service.railId);
        
        // Check if we need to add more fixed lockup for this payment
        if (rail.lockupFixed < amount) {
            uint256 additionalLockup = amount - rail.lockupFixed;
            
            // Add the required lockup funds
            payments.modifyRailLockup(
                service.railId,
                rail.lockupPeriod,
                rail.lockupFixed + additionalLockup
            );
        }
        
        // Issue the one-time payment through the rail system
        payments.modifyRailPayment(
            service.railId,
            rail.paymentRate, // Keep the same recurring rate
            amount            // One-time payment amount
        );
        
        emit UsagePaymentSent(serviceProvider, amount, reason);
    }

    // ========== ServiceUptimeListener Implementation ==========

    /**
     * @notice Called by ServiceUptimeVerifier when a service is registered
     * @dev Only the uptime verifier can call this
     */
    function serviceRegistered(uint256 serviceId, address provider, bytes calldata extraData) external onlyUptimeVerifier {
        (address serviceProvider, string memory metadata) = abi.decode(extraData, (address, string));
        // Service registration is handled in activateServiceProvider, this is just a confirmation callback
    }

    /**
     * @notice Called by ServiceUptimeVerifier when uptime is reported
     * @dev Only the uptime verifier can call this
     */
    function uptimeReported(uint256 serviceId, uint256 epoch, bool online, bytes calldata extraData) external onlyUptimeVerifier {
        // This callback can be used for additional business logic if needed
        // For now, we just rely on the verifier to store the uptime data
    }

    /**
     * @notice Called by ServiceUptimeVerifier when a service is deregistered
     * @dev Only the uptime verifier can call this
     */
    function serviceDeregistered(uint256 serviceId, bytes calldata extraData) external onlyUptimeVerifier {
        // Service deregistration is handled in deactivateServiceProvider, this is just a confirmation callback
    }

    // ========== Arbitration Functions ==========

    /**
     * @notice Arbitrates payment based on service provider online status from uptime verifier
     * @dev Only pays for epochs when service provider was online according to uptime verifier
     * @param railId ID of the payment rail
     * @param proposedAmount The originally proposed payment amount
     * @param fromEpoch Starting epoch (exclusive)
     * @param toEpoch Ending epoch (inclusive)
     * @return result The arbitration result
     */
    function arbitratePayment(
        uint256 railId,
        uint256 proposedAmount,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 /* rate */
    ) external override returns (ArbitrationResult memory result) {
        uint256 serviceId = railToService[railId];
        require(serviceId != 0, "Rail not associated with any service");

        ServiceInfo storage service = serviceInfo[serviceId];
        require(service.active, "Service not active");

        // Get uptime percentage from verifier
        uint256 uptimePercentage = ServiceUptimeVerifier(uptimeVerifierAddress).getUptimePercentage(
            serviceId,
            fromEpoch,
            toEpoch
        );
        
        // Calculate payment based on uptime percentage
        uint256 modifiedAmount = (proposedAmount * uptimePercentage) / 10000; // uptimePercentage is in basis points
        
        emit PaymentArbitrated(railId, serviceId, proposedAmount, modifiedAmount);

        return ArbitrationResult({
            modifiedAmount: modifiedAmount,
            settleUpto: toEpoch,
            note: "Payment calculated based on uptime percentage from verifier"
        });
    }

    // ========== Service Provider Registry Functions ==========
    
    /**
     * @notice Register as a service provider
     * @dev SPs call this to register before approval
     */
    function registerServiceProvider() external {
        require(!approvedProvidersMap[msg.sender], "Provider already approved");
        require(pendingProviders[msg.sender].registeredAt == 0, "Registration already pending");
        
        // Store pending registration
        pendingProviders[msg.sender] = PendingProviderInfo({
            registeredAt: block.number
        });
        
        emit ProviderRegistered(msg.sender);
    }
    
    /**
     * @notice Approve a pending service provider
     * @dev Only owner can approve providers
     * @param provider The address of the provider to approve
     */
    function approveServiceProvider(address provider) external onlyOwner {
        require(!approvedProvidersMap[provider], "Provider already approved");
        require(pendingProviders[provider].registeredAt > 0, "No pending registration found");
        
        // Get pending registration data
        PendingProviderInfo memory pending = pendingProviders[provider];
        
        // Assign ID and store provider info
        uint256 providerId = nextProviderId++;
        approvedProviders[providerId] = ApprovedProviderInfo({
            owner: provider,
            registeredAt: pending.registeredAt,
            approvedAt: block.number
        });
        
        approvedProvidersMap[provider] = true;
        providerToId[provider] = providerId;
        
        // Clear pending registration
        delete pendingProviders[provider];
        
        emit ProviderApproved(provider, providerId);
    }
    
    /**
     * @notice Reject a pending service provider
     * @dev Only owner can reject providers
     * @param provider The address of the provider to reject
     */
    function rejectServiceProvider(address provider) external onlyOwner {
        require(pendingProviders[provider].registeredAt > 0, "No pending registration found");
        require(!approvedProvidersMap[provider], "Provider already approved");
        
        // Clear pending registration
        delete pendingProviders[provider];
        
        emit ProviderRejected(provider);
    }

    /**
     * @notice Remove an approved service provider
     * @dev Only owner can remove providers
     * @param providerId The ID of the provider to remove
     */
    function removeServiceProvider(uint256 providerId) external onlyOwner {
        require(providerId > 0 && providerId < nextProviderId, "Invalid provider ID");
        
        ApprovedProviderInfo memory providerInfo = approvedProviders[providerId];
        address providerAddress = providerInfo.owner;
        require(providerAddress != address(0), "Provider not found");
        require(approvedProvidersMap[providerAddress], "Provider not approved");
        
        // Remove from approved mapping
        approvedProvidersMap[providerAddress] = false;
        delete providerToId[providerAddress];
        delete approvedProviders[providerId];
        
        emit ProviderRemoved(providerAddress, providerId);
    }

    // ========== View Functions ==========

    /**
     * @notice Get all approved providers
     * @return Array of approved provider information
     */
    function getAllApprovedProviders() external view returns (ApprovedProviderInfo[] memory) {
        if (nextProviderId == 1) {
            return new ApprovedProviderInfo[](0);
        }
        
        // Count active providers
        uint256 activeCount = 0;
        for (uint256 i = 1; i < nextProviderId; i++) {
            if (approvedProviders[i].owner != address(0)) {
                activeCount++;
            }
        }
        
        if (activeCount == 0) {
            return new ApprovedProviderInfo[](0);
        }
        
        // Fill array with active providers
        ApprovedProviderInfo[] memory providers = new ApprovedProviderInfo[](activeCount);
        uint256 currentIndex = 0;
        for (uint256 i = 1; i < nextProviderId; i++) {
            if (approvedProviders[i].owner != address(0)) {
                providers[currentIndex] = approvedProviders[i];
                currentIndex++;
            }
        }
        
        return providers;
    }

    /**
     * @notice Get service for a service provider
     * @param provider The service provider address
     * @return The service information (empty struct if no service)
     */
    function getProviderService(address provider) public view returns (ServiceInfo memory) {
        uint256 serviceId = providerToServiceId[provider];
        if (serviceId == 0) {
            // Return empty struct if no service
            return ServiceInfo({
                railId: 0,
                serviceProvider: address(0),
                metadata: "",
                ratePerEpoch: 0,
                active: false,
                createdAt: 0
            });
        }
        return serviceInfo[serviceId];
    }

    /**
     * @notice Get service information by ID
     * @param serviceId The service ID
     * @return The service information
     */
    function getService(uint256 serviceId) external view returns (ServiceInfo memory) {
        return serviceInfo[serviceId];
    }

    /**
     * @notice Check if a provider is approved
     * @param provider The address to check
     * @return True if approved, false otherwise
     */
    function isProviderApproved(address provider) external view returns (bool) {
        return approvedProvidersMap[provider];
    }
    
    /**
     * @notice Get the service name
     * @return The name of this service
     */
    function getServiceName() external view returns (string memory) {
        return serviceName;
    }
    
    /**
     * @notice Get the service description
     * @return The description of this service
     */
    function getServiceDescription() external view returns (string memory) {
        return serviceDescription;
    }
    
    /**
     * @notice Update service description (only owner)
     * @param _newDescription The new description (must be <= MAX_SERVICE_DESCRIPTION_SIZE)
     */
    function updateServiceDescription(string calldata _newDescription) external onlyOwner {
        require(bytes(_newDescription).length <= MAX_SERVICE_DESCRIPTION_SIZE, "Service description too large");
        serviceDescription = _newDescription;
    }

    /**
     * @notice Get the current lockup available for usage payments for a service provider
     * @param serviceProvider The address of the service provider
     * @return The amount of lockup funds available for usage payments
     */
    function getAvailableUsagePaymentFunds(address serviceProvider) external view returns (uint256) {
        uint256 serviceId = providerToServiceId[serviceProvider];
        if (serviceId == 0 || !serviceInfo[serviceId].active) {
            return 0;
        }
        
        Payments payments = Payments(paymentsContractAddress);
        Payments.RailView memory rail = payments.getRail(serviceInfo[serviceId].railId);
        return rail.lockupFixed;
    }

    /**
     * @notice Get service provider uptime from the verifier
     * @param serviceProvider The service provider address
     * @param fromEpoch Starting epoch
     * @param toEpoch Ending epoch
     * @return uptimePercentage Uptime percentage (0-10000 basis points)
     */
    function getServiceProviderUptime(
        address serviceProvider,
        uint256 fromEpoch,
        uint256 toEpoch
    ) external view returns (uint256 uptimePercentage) {
        // Find the active service for this provider
        uint256 serviceId = providerToServiceId[serviceProvider];
        if (serviceId != 0 && serviceInfo[serviceId].active) {
            return ServiceUptimeVerifier(uptimeVerifierAddress).getUptimePercentage(
                serviceId,
                fromEpoch,
                toEpoch
            );
        }
        return 0; // No active service found
    }

    /**
     * @notice Get current online status from the verifier
     * @param serviceProvider The service provider address
     * @return online Whether the service is currently online
     * @return lastReported The epoch when status was last reported
     */
    function getServiceProviderStatus(address serviceProvider) external view returns (bool online, uint256 lastReported) {
        // Find the active service for this provider
        uint256 serviceId = providerToServiceId[serviceProvider];
        if (serviceId != 0 && serviceInfo[serviceId].active) {
            return ServiceUptimeVerifier(uptimeVerifierAddress).getCurrentStatus(serviceId);
        }
        return (false, 0); // No active service found
    }

    /**
     * @notice Get approved provider info by ID
     * @param providerId The provider ID
     * @return The approved provider information
     */
    function getApprovedProvider(uint256 providerId) external view returns (ApprovedProviderInfo memory) {
        require(providerId > 0 && providerId < nextProviderId, "Invalid provider ID");
        ApprovedProviderInfo memory provider = approvedProviders[providerId];
        require(provider.owner != address(0), "Provider not found");
        return provider;
    }

    /**
     * @notice Get pending provider info
     * @param provider The provider address
     * @return The pending provider information
     */
    function getPendingProvider(address provider) external view returns (PendingProviderInfo memory) {
        return pendingProviders[provider];
    }

    /**
     * @notice Get provider ID by address
     * @param provider The provider address
     * @return The provider ID (0 if not approved)
     */
    function getProviderIdByAddress(address provider) external view returns (uint256) {
        return providerToId[provider];
    }
}
